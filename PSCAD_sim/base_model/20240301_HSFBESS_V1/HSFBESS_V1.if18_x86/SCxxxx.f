!=======================================================================
! Generated by: PSCAD v5.0.1.0
! Warning:  The content of this file is automatically generated.
!           Do not modify, as any changes made here will be lost!
!-----------------------------------------------------------------------
! Component     : SCxxxx
! Description   : SMA  SC xxxx
!-----------------------------------------------------------------------


!=======================================================================

      SUBROUTINE SCxxxxDyn(Spt, Fb, FileNum, InvPwrVolTyp_, GriCod_,    &
     &   Log2File, FastStart, DPS_Spt, DPS_Fb, DEBUG_PCU, MEAS_PCU)

!---------------------------------------
! Standard includes 
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 'emtstor.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's2.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'fnames.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'matlab.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations 
!---------------------------------------

!     SUBR    EMTDC_X2COMP  ! 'Comparator with Interpolation'
!     SUBR    EMTDC_XSGEN   ! 'Signal Generator /w Interpolation'
!     SUBR    EMTDC_XONDLAY  ! 'Delay Function with Interpolation'
!     SUBR    AvgBridgeDyn  ! 

!---------------------------------------
! Variable Declarations 
!---------------------------------------


! Subroutine Arguments
      INTEGER, INTENT(IN)  :: FileNum
      INTEGER, INTENT(IN)  :: InvPwrVolTyp_
      INTEGER, INTENT(IN)  :: GriCod_, Log2File
      INTEGER, INTENT(IN)  :: FastStart
      REAL,    INTENT(IN)  :: Spt(10), DPS_Fb(10)
      REAL,    INTENT(OUT) :: DPS_Spt(5)
      REAL,    INTENT(OUT) :: DEBUG_PCU(100)
      REAL,    INTENT(OUT) :: MEAS_PCU(17)
      REAL,    INTENT(OUT) :: Fb(10)! Aliases: PCSFb

! Electrical Node Indices

! Control Signals
      INTEGER  IT_1, ACC, ACCI, Up, Execute
      INTEGER  CapCon, CAPCONI, FileNo
      INTEGER  InvPwrVolTyp, Log2File_
      INTEGER  FastStart_, DCCI1, DCCI, DCCI2
      INTEGER  PreChrg, PRECHRGI, CAPPRECHRG
      INTEGER  CAPPRECHRGI, DCC, GriCod, FST_BRK
      REAL     EnaPWM, DutyCycle(3), ExtVRMS
      REAL     RT_1(2), RT_2(2), VAREF, VPWM
      REAL     VBREF, RT_3(2), VCREF, RT_4(2)
      REAL     RT_5(2), RT_6(2), RT_7(2)
      REAL     ExtVtgAB, ExtVtgBC, ExtVtgCA
      REAL     CnvVtgAB, CnvVtgBC, CnvVtgCA
      REAL     RT_8(2), RT_9(2), RT_10(2)
      REAL     RT_11(2), RT_12(2), PVCurFil
      REAL     RT_13, RT_14(3), StackCur_(3)
      REAL     PVVtgFil, RT_15, DCLinkVtgFil
      REAL     RT_16, g1(2), DeadTime, g4(2)
      REAL     g3(2), g6(2), g5(2), g2(2)
      REAL     StackCurFil(3), RT_17(3), VDCRef
      REAL     RT_18(50), RT_19, RT_20, RT_21
      REAL     RT_22, RT_23, Meas(20)
      REAL     ZeroArray(10), RT_24, CnvVtgFil(3)
      REAL     ExtVtgFil(3), RT_25, RT_26, RT_27
      REAL     ExtVtg(3), CnvVtg(3), StackCur(3)
      REAL     CnvCurABC(3), CnvPAC, CnvQAC
      REAL     PVVtg, Ipv, DCLinkVtg, RT_28
      REAL     RT_29, FPWM, C_Filter, L_Filter
      REAL     R_Filter, HwParam(4), C_Dcl
      REAL     xout(50), PVCur, Istk

! Internal Variables
      INTEGER  IVD1_1, Look_for_Max, NSTORF_SAVE
      INTEGER  NSTORI_SAVE, HW_PWM, bSHORT_B6
      INTEGER  LOCAL_EXECUTE, i, IVD1_2, IVD1_3
      INTEGER  IVD1_4
      REAL     RVD2_1(2), DELT_CTL, LOCAL_TIME
      REAL     DEBUG_REAL(100), LevelHi, LevelLo
      REAL     Num_K2_Stacks, xdata(10)

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER ISTOI, ISTOF, IT_0                  ! Storage Indices
      INTEGER ISUBS, SS(2), IBRCH(2), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices 
!---------------------------------------

! Dsdyn <-> Dsout transfer index storage

      NTXFR = NTXFR + 1

      TXFR(NTXFR,1) = NSTOL
      TXFR(NTXFR,2) = NSTOI
      TXFR(NTXFR,3) = NSTOF
      TXFR(NTXFR,4) = NSTOC

! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      ISTOI     = NSTOI
      NSTOI     = NSTOI + 26
      ISTOF     = NSTOF
      NSTOF     = NSTOF + 398
      INODE     = NNODE + 2
      NNODE     = NNODE + 35
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 2

      DO IT_0 = 1,2
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 32


      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 8

!---------------------------------------
! Transfers from storage arrays 
!---------------------------------------

      EnaPWM   = STOF(ISTOF + 153)
      IT_1     = STOI(ISTOI + 6)
      ExtVRMS  = STOF(ISTOF + 157)
      VAREF    = STOF(ISTOF + 162)
      VPWM     = STOF(ISTOF + 163)
      VBREF    = STOF(ISTOF + 164)
      VCREF    = STOF(ISTOF + 167)
      ExtVtgAB = STOF(ISTOF + 176)
      ExtVtgBC = STOF(ISTOF + 177)
      ExtVtgCA = STOF(ISTOF + 178)
      CnvVtgAB = STOF(ISTOF + 179)
      CnvVtgBC = STOF(ISTOF + 180)
      CnvVtgCA = STOF(ISTOF + 181)
      ACC      = STOI(ISTOI + 7)
      ACCI     = STOI(ISTOI + 8)
      PVCurFil = STOF(ISTOF + 192)
      RT_13    = STOF(ISTOF + 193)
      PVVtgFil = STOF(ISTOF + 200)
      RT_15    = STOF(ISTOF + 201)
      DCLinkVtgFil = STOF(ISTOF + 202)
      RT_16    = STOF(ISTOF + 203)
      DeadTime = STOF(ISTOF + 206)
      Up       = STOI(ISTOI + 9)
      Execute  = STOI(ISTOI + 10)
      CapCon   = STOI(ISTOI + 11)
      CAPCONI  = STOI(ISTOI + 12)
      VDCRef   = STOF(ISTOF + 223)
      FileNo   = STOI(ISTOI + 13)
      InvPwrVolTyp = STOI(ISTOI + 14)
      Log2File_ = STOI(ISTOI + 15)
      FastStart_ = STOI(ISTOI + 16)
      DCCI1    = STOI(ISTOI + 17)
      DCCI     = STOI(ISTOI + 18)
      DCCI2    = STOI(ISTOI + 19)
      PreChrg  = STOI(ISTOI + 20)
      PRECHRGI = STOI(ISTOI + 21)
      RT_19    = STOF(ISTOF + 274)
      RT_20    = STOF(ISTOF + 275)
      RT_21    = STOF(ISTOF + 276)
      RT_22    = STOF(ISTOF + 277)
      CAPPRECHRG = STOI(ISTOI + 22)
      CAPPRECHRGI = STOI(ISTOI + 23)
      RT_23    = STOF(ISTOF + 278)
      DCC      = STOI(ISTOI + 24)
      RT_24    = STOF(ISTOF + 309)
      RT_25    = STOF(ISTOF + 316)
      RT_26    = STOF(ISTOF + 317)
      RT_27    = STOF(ISTOF + 318)
      CnvPAC   = STOF(ISTOF + 331)
      CnvQAC   = STOF(ISTOF + 332)
      PVVtg    = STOF(ISTOF + 333)
      Ipv      = STOF(ISTOF + 334)
      DCLinkVtg = STOF(ISTOF + 335)
      GriCod   = STOI(ISTOI + 25)
      RT_28    = STOF(ISTOF + 336)
      RT_29    = STOF(ISTOF + 337)
      FST_BRK  = STOI(ISTOI + 26)
      FPWM     = STOF(ISTOF + 338)
      C_Filter = STOF(ISTOF + 339)
      L_Filter = STOF(ISTOF + 340)
      R_Filter = STOF(ISTOF + 341)
      C_Dcl    = STOF(ISTOF + 346)
      PVCur    = STOF(ISTOF + 397)
      Istk     = STOF(ISTOF + 398)

! Array (1:2) quantities...
      DO IT_0 = 1,2
         RT_1(IT_0) = STOF(ISTOF + 157 + IT_0)
         RT_2(IT_0) = STOF(ISTOF + 159 + IT_0)
         RT_3(IT_0) = STOF(ISTOF + 164 + IT_0)
         RT_4(IT_0) = STOF(ISTOF + 167 + IT_0)
         RT_5(IT_0) = STOF(ISTOF + 169 + IT_0)
         RT_6(IT_0) = STOF(ISTOF + 171 + IT_0)
         RT_7(IT_0) = STOF(ISTOF + 173 + IT_0)
         RT_8(IT_0) = STOF(ISTOF + 181 + IT_0)
         RT_9(IT_0) = STOF(ISTOF + 183 + IT_0)
         RT_10(IT_0) = STOF(ISTOF + 185 + IT_0)
         RT_11(IT_0) = STOF(ISTOF + 187 + IT_0)
         RT_12(IT_0) = STOF(ISTOF + 189 + IT_0)
         g1(IT_0) = STOF(ISTOF + 203 + IT_0)
         g4(IT_0) = STOF(ISTOF + 206 + IT_0)
         g3(IT_0) = STOF(ISTOF + 208 + IT_0)
         g6(IT_0) = STOF(ISTOF + 210 + IT_0)
         g5(IT_0) = STOF(ISTOF + 212 + IT_0)
         g2(IT_0) = STOF(ISTOF + 214 + IT_0)
      END DO

! Array (1:3) quantities...
      DO IT_0 = 1,3
         DutyCycle(IT_0) = STOF(ISTOF + 153 + IT_0)
         RT_14(IT_0) = STOF(ISTOF + 193 + IT_0)
         StackCur_(IT_0) = STOF(ISTOF + 196 + IT_0)
         StackCurFil(IT_0) = STOF(ISTOF + 216 + IT_0)
         RT_17(IT_0) = STOF(ISTOF + 219 + IT_0)
         CnvVtgFil(IT_0) = STOF(ISTOF + 309 + IT_0)
         ExtVtgFil(IT_0) = STOF(ISTOF + 312 + IT_0)
         ExtVtg(IT_0) = STOF(ISTOF + 318 + IT_0)
         CnvVtg(IT_0) = STOF(ISTOF + 321 + IT_0)
         StackCur(IT_0) = STOF(ISTOF + 324 + IT_0)
         CnvCurABC(IT_0) = STOF(ISTOF + 327 + IT_0)
      END DO

! Array (1:4) quantities...
      DO IT_0 = 1,4
         HwParam(IT_0) = STOF(ISTOF + 341 + IT_0)
      END DO

! Array (1:5) quantities...
      DO IT_0 = 1,5
         DPS_Spt(IT_0) = STOF(ISTOF + 20 + IT_0)
      END DO

! Array (1:10) quantities...
      DO IT_0 = 1,10
         Fb(IT_0) = STOF(ISTOF + 10 + IT_0)
         ZeroArray(IT_0) = STOF(ISTOF + 298 + IT_0)
      END DO

! Array (1:17) quantities...
      DO IT_0 = 1,17
         MEAS_PCU(IT_0) = STOF(ISTOF + 135 + IT_0)
      END DO

! Array (1:20) quantities...
      DO IT_0 = 1,20
         Meas(IT_0) = STOF(ISTOF + 278 + IT_0)
      END DO

! Array (1:50) quantities...
      DO IT_0 = 1,50
         RT_18(IT_0) = STOF(ISTOF + 223 + IT_0)
         xout(IT_0) = STOF(ISTOF + 346 + IT_0)
      END DO

! Array (1:100) quantities...
      DO IT_0 = 1,100
         DEBUG_PCU(IT_0) = STOF(ISTOF + 35 + IT_0)
      END DO


!---------------------------------------
! Electrical Node Lookup 
!---------------------------------------


!---------------------------------------
! Configuration of Models 
!---------------------------------------

      IF ( TIMEZERO ) THEN
         FILENAME = 'SCxxxx.dta'
         CALL EMTDC_OPENFILE
         SECTION = 'DATADSD:'
         CALL EMTDC_GOTOSECTION
      ENDIF
!---------------------------------------
! Generated code from module definition 
!---------------------------------------


! 30:[time-sig] Output of Simulation Time 
      RT_29 = TIME

! 40:[const] Real Constant 
      VDCRef = 750.0

! 190:[unity] Type/Shape conversion block 
! integer -> integer
      FileNo = FileNum

! 210:[unity] Type/Shape conversion block 
! integer -> integer
      Log2File_ = Log2File

! 230:[unity] Type/Shape conversion block 
! integer -> integer
      InvPwrVolTyp = InvPwrVolTyp_

! 250:[unity] Type/Shape conversion block 
! integer -> integer
      FastStart_ = FastStart

! 300:[unity] Type/Shape conversion block 
! integer -> integer
      GriCod = GriCod_

! 310:[time-sig] Output of Simulation Time 
      RT_24 = TIME

! 320:[const] Real Constant 'TDead'
      DeadTime = 0.0

! 380:[const] Real Constant 
      RT_25 = 0.0

! 410:[const] Real Constant 
      RT_26 = 0.0

! 460:[const] Real Constant 'Zero'
      RT_27 = 0.0

! 470:[gain] Gain Block 
!  Gain
      RT_28 = 0.001 * REAL(FastStart)

! 480:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(0,0,RT_28,RT_29,0.0,0.0,1.0,RVD2_1)
      FST_BRK = NINT(RVD2_1(1))

! 490:[datamerge] Merges data signals into an array 
      Meas(1) = RT_24
      Meas(2 : 4) = CnvVtgFil
      Meas(5 : 7) = ExtVtgFil
      Meas(8 : 10) = StackCur_
      Meas(11 : 13) = StackCurFil
      Meas(14) = PVVtgFil
      Meas(15) = DCLinkVtgFil
      Meas(16) = PVCurFil
      Meas(17) = RT_25
      Meas(18) = RT_26
      Meas(19) = RT_26
      Meas(20) = RT_26

! 500:[datamerge] Merges data signals into an array 
      ZeroArray(1) = RT_27
      ZeroArray(2) = RT_27
      ZeroArray(3) = RT_27
      ZeroArray(4) = RT_27
      ZeroArray(5) = RT_27
      ZeroArray(6) = RT_27
      ZeroArray(7) = RT_27
      ZeroArray(8) = RT_27
      ZeroArray(9) = RT_27
      ZeroArray(10) = RT_27

! 510:[datamerge] Merges data signals into an array 
      RT_18(1 : 20) = Meas
      RT_18(21 : 30) = Spt
      RT_18(31 : 40) = DPS_Fb
      RT_18(41 : 50) = ZeroArray

! 520:[SMA_PWM] SMA PWM Signal Gen with Interpolation & Sampling 
!
      CALL EMTDC_XSGEN(1,0,0.0,FPWM,50.0,1.0,-1.0,RVD2_1)
      VPWM = RVD2_1(1)
!
! Generate Execute Outputs for SMA Code
!
! Controller code should sample inputs and perform calculations
! at the Peak of a PWM waveform.
!
! The Duty Cycle output from the controller is output and used
! in the comparator.
!
! This component will output an Execute output on every maximum and
! minimum.  The controller code for the PSCAD model
! internally has a Z-1 delay of one sample time so the Duty Cycle
! is used only on the 2nd minimum after the controller code is sampled.
!
! STORF(NSTORF+0) is the old PWM Output signal
! Once a max is detected, the code will start looking for a minimum (ie Look_for_Max = 1)
! Once a min is detected, the code will start looking for a maximum (ie Look_for_Max = 0)
!
      Execute = 0
! Restore Old Values
      Look_for_Max = STORI(NSTORI)
      IF ( Look_for_Max .GE. 1) THEN
         IF ( VPWM .LE. STORF(NSTORF) ) THEN
! Found a maximum
            Execute = 1
            Look_for_Max  = 0
         ENDIF
      ELSE
         IF ( VPWM .GE. STORF(NSTORF) ) THEN
! Found a minimum
            Execute = 1
            Look_for_Max  = 1
         ENDIF
      ENDIF
      Up = Look_for_Max
      STORF(NSTORF) = VPWM
      NSTORF = NSTORF + 1
      STORI(NSTORI) = Look_for_Max
      NSTORI = NSTORI + 1

! 530:[SMA_SCK] Sunny Central - SMA Controller model 
!1000V/1100V K1 device
      IF ((InvPwrVolTyp .EQ. Z'502').OR.(InvPwrVolTyp .EQ. Z'100').OR.(I&
     &nvPwrVolTyp .EQ. Z'102').OR.(InvPwrVolTyp .EQ. Z'10100').OR.(InvPw&
     &rVolTyp .EQ. Z'10102').OR.(InvPwrVolTyp .EQ. Z'300').OR.(InvPwrVol&
     &Typ .EQ. Z'10300').OR.(InvPwrVolTyp .EQ. Z'10302').OR.(InvPwrVolTy&
     &p .EQ. Z'10B00').OR.(InvPwrVolTyp .EQ. Z'10B02'))THEN
!C_Filter
      HwParam(1) = 445
!L_Filter
      HwParam(2) = 48e-6
!RL
      HwParam(3) = 0.0005
!C_dcl
      HwParam(4) = 22808
      LevelHi = 3*2500
      LevelLo = 3*2000
!Number of K2 stacks for the dynamic HW current limitation (K1 is not dynamic -> 0)
      Num_K2_Stacks = 0

!Kodiak 2.0
      ELSEIF ((InvPwrVolTyp .EQ. 4).OR.(InvPwrVolTyp .EQ. Z'4001').OR.(I&
     &nvPwrVolTyp .EQ. Z'4003').OR.(InvPwrVolTyp .EQ. Z'14001').OR.(InvP&
     &wrVolTyp .EQ. Z'14003').OR.(InvPwrVolTyp .EQ. Z'4101').OR.(InvPwrV&
     &olTyp .EQ. Z'4103').OR.(InvPwrVolTyp .EQ. Z'14101').OR.(InvPwrVolT&
     &yp .EQ. Z'14103').OR.(InvPwrVolTyp .EQ. Z'4201').OR.(InvPwrVolTyp &
     &.EQ. Z'4203').OR.(InvPwrVolTyp .EQ. Z'14201').OR.(InvPwrVolTyp .EQ&
     &. Z'14203').OR.(InvPwrVolTyp .EQ. Z'4301').OR.(InvPwrVolTyp .EQ. Z&
     &'4303').OR.(InvPwrVolTyp .EQ. Z'14301').OR.(InvPwrVolTyp .EQ. Z'14&
     &303').OR.(InvPwrVolTyp .EQ. Z'14E01').OR.(InvPwrVolTyp .EQ. Z'14E0&
     &3').OR.(InvPwrVolTyp .EQ. Z'14F01').OR.(InvPwrVolTyp .EQ. Z'14F03'&
     &).OR.(InvPwrVolTyp .EQ. Z'15001').OR.(InvPwrVolTyp .EQ. Z'15003').&
     &OR.(InvPwrVolTyp .EQ. Z'15101').OR.(InvPwrVolTyp .EQ. Z'15103'))TH&
     &EN
!C_Filter
      HwParam(1) = 266
!L_Filter
      HwParam(2) = 64.0e-06
!RL
      HwParam(3) = 0.002
!C_dcl
      HwParam(4) = 17820
      LevelHi = 3*3000
      LevelLo = 3*2500
!Number of K2 stacks for the dynamic HW current limitation (K1 is not dynamic -> 0)
      Num_K2_Stacks = 3

!Kodiak 2.0  w. 2 Stk.
      ELSEIF ((InvPwrVolTyp .EQ. Z'4401').OR.(InvPwrVolTyp .EQ. Z'4403')&
     &.OR.(InvPwrVolTyp .EQ. Z'14401').OR.(InvPwrVolTyp .EQ. Z'14403').O&
     &R.(InvPwrVolTyp .EQ. Z'4501').OR.(InvPwrVolTyp .EQ. Z'4503').OR.(I&
     &nvPwrVolTyp .EQ. Z'14501').OR.(InvPwrVolTyp .EQ. Z'14503').OR.(Inv&
     &PwrVolTyp .EQ. Z'4601').OR.(InvPwrVolTyp .EQ. Z'4603').OR.(InvPwrV&
     &olTyp .EQ. Z'14601').OR.(InvPwrVolTyp .EQ. Z'14603').OR.(InvPwrVol&
     &Typ .EQ. Z'4701').OR.(InvPwrVolTyp .EQ. Z'4703').OR.(InvPwrVolTyp &
     &.EQ. Z'14701').OR.(InvPwrVolTyp .EQ. Z'14703'))THEN
!C_Filter
      HwParam(1) = 266
!L_Filter
      HwParam(2) = 91e-06
!RL
      HwParam(3) = 0.002
!C_dcl
      HwParam(4) = 11880
      LevelHi = 2*3000
      LevelLo = 2*2500
!Number of K2 stacks for the dynamic HW current limitation (K1 is not dynamic -> 0)
      Num_K2_Stacks = 2

      ELSE
!1500V K1 device
!C_Filter
      HwParam(1) = 280
!L_Filter
      HwParam(2) = 86e-6
!RL
      HwParam(3) = 0.0005
!C_dcl
      HwParam(4) = 10808
      LevelHi = 3*1666
      LevelLo = 3*1333
!Number of K2 stacks for the dynamic HW current limitation (K1 is not dynamic -> 0)
      Num_K2_Stacks = 0
      ENDIF

! 530:[SMA_SCK] Sunny Central - SMA Controller model 
! SMA PLL



! Sample Time required by the SMA Controls
      DELT_CTL = 1.0/6000.0  ! The SMA controls require a 6 kHz Sample Rate

! Save Storage pointers for the output state variables and increment by the number of vars used for the FORTRAN part
      NSTORF_SAVE = NSTORF
      NSTORI_SAVE = NSTORI
      NSTORF = NSTORF + 50
      NSTORI = NSTORI + 4

! Set Initial Conditions of State Variables
      IF ( TIMEZERO ) THEN

! Set Initial state of time step counter
         STORI(NSTORI_SAVE+0) = 0
      ELSE
! Increment time step counter by the simulation time step (DELT)
         STORI(NSTORI_SAVE+0) = STORI(NSTORI_SAVE+0) + 1
      ENDIF

      IF ( TIMEZERO .OR. (STORI(NSTORI_SAVE+0).GE.NINT(DELT_CTL/DELT)) )&
     & THEN
                LOCAL_EXECUTE = 1
      ELSE
                LOCAL_EXECUTE = 0
      ENDIF

      IF ( FIRSTSTEP ) THEN
! Set marker that it is the first step after a new start
         STORI(NSTORI_SAVE+1) = 1
      ENDIF

! Retrieve from Storage
        bShort_B6 = STORI(NSTORI_SAVE+2)
        HW_PWM     = STORI(NSTORI_SAVE+3)
       do i = 1, 50
           xout(i)= STORF(NSTORF_SAVE+i-1)
       end do

! Hardware over-current detection (K1 -> fixed off/on levels; K2 -> configurable levels)
      IF (Num_K2_Stacks .GT. 0) THEN
! K2 inverters: limits are at pos 26 and 27 (FORTRAN) in the xout array)
        IF ( MAX(ABS(RT_18(8)),ABS(RT_18(9)),ABS(RT_18(10))).GE. xout(26&
     &)*Num_K2_Stacks ) THEN
         HW_PWM    = 0
         bSHORT_B6 = 1
        ENDIF
        IF ( MAX(ABS(RT_18(8)),ABS(RT_18(9)),ABS(RT_18(10))).LE. xout(27&
     &)*Num_K2_Stacks ) THEN
         HW_PWM    = 1
! Note: Clearing of bSHORT_B6 is done inside the controls on its 3kHz step
        ENDIF
      ELSE
! K1 inverters
        IF ( MAX(ABS(RT_18(8)),ABS(RT_18(9)),ABS(RT_18(10))).GE. LevelHi&
     & ) THEN
         HW_PWM    = 0
         bSHORT_B6 = 1
        ENDIF
        IF ( MAX(ABS(RT_18(8)),ABS(RT_18(9)),ABS(RT_18(10))).LE. LevelLo&
     & ) THEN
         HW_PWM    = 1
! Note: Clearing of bSHORT_B6 is done inside the controls on its 3kHz step
        ENDIF
      ENDIF


      STORI(NSTORI_SAVE+2) = bSHORT_B6
      STORI(NSTORI_SAVE+3) = HW_PWM


!      IF ( LOCAL_EXECUTE .GE. 1 ) THEN
      IF ( Execute .GE. 1 ) THEN

! Reset timer
         STORI(NSTORI_SAVE+0) = 0

      xdata(1) = STORI(NSTORI_SAVE+1)
      xdata(2) = InvPwrVolTyp
      xdata(3) = FileNo
      xdata(4) = Log2File_
      xdata(5) = FastStart_
      xdata(6) = GriCod
      xdata(7) = 1
! Reset the FIRSTSTEP flag
      STORI(NSTORI_SAVE+1) = 0

! Info if overcurrent
      RT_18(17) = bSHORT_B6

! SMA Controller
         CALL SMA_SCK_FInterface(xdata, RT_18, xout,  Up,VDCRef,  Fb , D&
     &EBUG_REAL, FileNo, Log2File_, FastStart_)

! Transfer Debug information
         DEBUG_PCU     = DEBUG_REAL

! Put into storage
        do i = 1, 50
           STORF(NSTORF_SAVE+i-1) = xout(i)
        end do

         STORI(NSTORI_SAVE+2) = 0  ! reset bSHORT_B6 because controls have been called
      ENDIF

! Blocking of firing pulses if the HW overcurrent detection has activated
      xout(2) = STORF(NSTORF_SAVE+1)  * HW_PWM

        DEBUG_PCU(99)  =  xout(26)*Num_K2_Stacks
        DEBUG_PCU(100) =  xout(27)*Num_K2_Stacks
! Increment of Storage Pointers for the SMA code is done here
! because it must be incremented for every time step (not juss steps where the SMA code is called)
      NSTORI = NSTORI + 20000

! 540:[datatap] Scalar/Array Tap 
      FPWM = xout(1)

! 550:[datatap] Scalar/Array Tap 
      DutyCycle = xout(3 : 5)

! 560:[datatap] Scalar/Array Tap 
      VCREF = DutyCycle(3)

! 570:[datatap] Scalar/Array Tap 
      VBREF = DutyCycle(2)

! 580:[datatap] Scalar/Array Tap 
      VAREF = DutyCycle(1)

! 590:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(1,0,VCREF,VPWM,1.0,0.0,0.0,RT_4)

! 600:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(1,0,VBREF,VPWM,1.0,0.0,0.0,RT_3)

! 610:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(1,0,VAREF,VPWM,1.0,0.0,0.0,RT_1)

! 620:[datatap] Scalar/Array Tap 
      RT_19 = xout(6)

! 630:[inv] Interpolated Logic Inverter 
      IF (NINT(RT_4(1)) .NE. 0) THEN
         RT_7(1) = 0.0
      ELSE
         RT_7(1) = 1.0
      ENDIF
      RT_7(2) = RT_4(2)

! 640:[inv] Interpolated Logic Inverter 
      IF (NINT(RT_3(1)) .NE. 0) THEN
         RT_6(1) = 0.0
      ELSE
         RT_6(1) = 1.0
      ENDIF
      RT_6(2) = RT_3(2)

! 650:[inv] Interpolated Logic Inverter 
      IF (NINT(RT_1(1)) .NE. 0) THEN
         RT_2(1) = 0.0
      ELSE
         RT_2(1) = 1.0
      ENDIF
      RT_2(2) = RT_1(2)

! 660:[datatap] Scalar/Array Tap 
      RT_23 = xout(10)

! 670:[datatap] Scalar/Array Tap 
      RT_22 = xout(9)

! 680:[datatap] Scalar/Array Tap 
      RT_21 = xout(8)

! 690:[datatap] Scalar/Array Tap 
      RT_20 = xout(7)

! 700:[unity] Type/Shape conversion block 
! real -> integer
      ACC = INT(RT_19)

! 710:[datatap] Scalar/Array Tap 
      EnaPWM = xout(2)

! 720:[gain] Gain Block 
!  Gain
      RT_12 = EnaPWM * RT_7

! 730:[gain] Gain Block 
!  Gain
      RT_10 = EnaPWM * RT_6

! 740:[gain] Gain Block 
!  Gain
      RT_8 = EnaPWM * RT_2

! 750:[unity] Type/Shape conversion block 
! real -> integer
      DCC = INT(RT_23)

! 760:[unity] Type/Shape conversion block 
! real -> integer
      CAPPRECHRG = INT(RT_22)

! 770:[unity] Type/Shape conversion block 
! real -> integer
      CapCon = INT(RT_21)

! 780:[unity] Type/Shape conversion block 
! real -> integer
      PreChrg = INT(RT_20)

! 790:[inv] Interpolated Logic Inverter 
      IF (ACC .NE. 0) THEN
         ACCI = 0
      ELSE
         ACCI = 1
      ENDIF

! 800:[breaker3] 3 Phase Breaker 'ACCI'
      IVD1_4 = NSTORI
      NSTORI = NSTORI + 3
! Three Phase Breaker
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+4),0.0001,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(ACCI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+5),0.0001,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(ACCI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+6),0.0001,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(ACCI)))
!
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(1)+4),SS(1)))
      IVD1_2 = 2*E_BtoI(OPENBR( (IBRCH(1)+5),SS(1)))
      IVD1_3 = 2*E_BtoI(OPENBR( (IBRCH(1)+6),SS(1)))
      NRTCF = NRTCF + 1
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+0) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,945457058,IVD1_1,"BOpen1")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+1) .NE. IVD1_2)) THEN
         CALL PSCAD_AGI2(ICALL_NO,945457058,IVD1_2,"BOpen2")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+2) .NE. IVD1_3)) THEN
         CALL PSCAD_AGI2(ICALL_NO,945457058,IVD1_3,"BOpen3")
      ENDIF
      STORI(IVD1_4+0) = 2*E_BtoI(OPENBR( (IBRCH(1)+4),SS(1)))
      STORI(IVD1_4+1) = 2*E_BtoI(OPENBR( (IBRCH(1)+5),SS(1)))
      STORI(IVD1_4+2) = 2*E_BtoI(OPENBR( (IBRCH(1)+6),SS(1)))

! 810:[datatap] Scalar/Array Tap 
      C_Dcl = HwParam(4)

! 820:[datatap] Scalar/Array Tap 
      R_Filter = HwParam(3)

! 830:[datatap] Scalar/Array Tap 
      L_Filter = HwParam(2)

! 840:[datatap] Scalar/Array Tap 
      C_Filter = HwParam(1)

! 850:[datamerge] Merges data signals into an array 
      MEAS_PCU(1 : 3) = ExtVtg
      MEAS_PCU(4 : 6) = CnvVtg
      MEAS_PCU(7 : 9) = StackCur
      MEAS_PCU(10 : 12) = CnvCurABC
      MEAS_PCU(13) = CnvPAC
      MEAS_PCU(14) = CnvQAC
      MEAS_PCU(15) = PVVtg
      MEAS_PCU(16) = Ipv
      MEAS_PCU(17) = DCLinkVtg

! 860:[datatap] Scalar/Array Tap 
      DPS_Spt = xout(21 : 25)

! 870:[delay] Binary ON Delay with Interpolation 
!
      CALL EMTDC_XONDLAY(1,DeadTime,RT_12,g2)

! 880:[gain] Gain Block 
!  Gain
      RT_11 = EnaPWM * RT_4

! 890:[delay] Binary ON Delay with Interpolation 
!
      CALL EMTDC_XONDLAY(1,DeadTime,RT_11,g5)

! 910:[delay] Binary ON Delay with Interpolation 
!
      CALL EMTDC_XONDLAY(1,DeadTime,RT_10,g6)

! 920:[gain] Gain Block 
!  Gain
      RT_9 = EnaPWM * RT_3

! 930:[delay] Binary ON Delay with Interpolation 
!
      CALL EMTDC_XONDLAY(1,DeadTime,RT_9,g3)

! 940:[delay] Binary ON Delay with Interpolation 
!
      CALL EMTDC_XONDLAY(1,DeadTime,RT_8,g4)

! 950:[inv] Interpolated Logic Inverter 
      IF (DCC .NE. 0) THEN
         DCCI = 0
      ELSE
         DCCI = 1
      ENDIF

! 960:[gain] Gain Block 
!  Gain
      RT_5 = EnaPWM * RT_1

! 970:[delay] Binary ON Delay with Interpolation 
!
      CALL EMTDC_XONDLAY(1,DeadTime,RT_5,g1)

! 980:[inv] Interpolated Logic Inverter 
      IF (CAPPRECHRG .NE. 0) THEN
         CAPPRECHRGI = 0
      ELSE
         CAPPRECHRGI = 1
      ENDIF

! 990:[inv] Interpolated Logic Inverter 
      IF (CapCon .NE. 0) THEN
         CAPCONI = 0
      ELSE
         CAPCONI = 1
      ENDIF

! 1000:[inv] Interpolated Logic Inverter 
      IF (PreChrg .NE. 0) THEN
         PRECHRGI = 0
      ELSE
         PRECHRGI = 1
      ENDIF

! 1010:[unity] Type/Shape conversion block 
! integer -> integer
      DCCI2 = DCCI

! 1020:[unity] Type/Shape conversion block 
! integer -> integer
      DCCI1 = DCCI

! 1030:[varrlc] Variable R, L or C  
      CALL COMPONENT_ID(ICALL_NO,1754306402)
      CALL E_VARRLC1_EXE(2 ,SS(1) ,  (IBRCH(1)+12), 0, C_Filter, 0.0)

! 1040:[varrlc] Variable R, L or C  
      CALL COMPONENT_ID(ICALL_NO,1582962471)
      CALL E_VARRLC1_EXE(2 ,SS(1) ,  (IBRCH(1)+10), 0, C_Filter, 0.0)

! 1050:[varrlc] Variable R, L or C  
      CALL COMPONENT_ID(ICALL_NO,785315853)
      CALL E_VARRLC1_EXE(2 ,SS(1) ,  (IBRCH(1)+11), 0, C_Filter, 0.0)

! 1060:[breaker3] 3 Phase Breaker 'PRECHRGI'
      IVD1_4 = NSTORI
      NSTORI = NSTORI + 3
! Three Phase Breaker
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+22),0.001,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(PRECHRGI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+23),0.001,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(PRECHRGI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+24),0.001,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(PRECHRGI)))
!
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(1)+22),SS(1)))
      IVD1_2 = 2*E_BtoI(OPENBR( (IBRCH(1)+23),SS(1)))
      IVD1_3 = 2*E_BtoI(OPENBR( (IBRCH(1)+24),SS(1)))
      NRTCF = NRTCF + 1
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+0) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,1421691469,IVD1_1,"BOpen1")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+1) .NE. IVD1_2)) THEN
         CALL PSCAD_AGI2(ICALL_NO,1421691469,IVD1_2,"BOpen2")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+2) .NE. IVD1_3)) THEN
         CALL PSCAD_AGI2(ICALL_NO,1421691469,IVD1_3,"BOpen3")
      ENDIF
      STORI(IVD1_4+0) = 2*E_BtoI(OPENBR( (IBRCH(1)+22),SS(1)))
      STORI(IVD1_4+1) = 2*E_BtoI(OPENBR( (IBRCH(1)+23),SS(1)))
      STORI(IVD1_4+2) = 2*E_BtoI(OPENBR( (IBRCH(1)+24),SS(1)))

! 1070:[breaker1] Single Phase Breaker 'FST_BRK'
      IVD1_2 = NSTORI
      NSTORI = NSTORI + 1
      CALL E1PBRKR1_EXE(SS(2), (IBRCH(2)+3),1.0,1000000.0,1,NINT(1.0-REA&
     &L(FST_BRK)))
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(2)+3),SS(2)))
      IF (FIRSTSTEP .OR. (STORI(IVD1_2) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,640815522,IVD1_1,"BOpen")
      ENDIF
      STORI(IVD1_2) = 2*E_BtoI(OPENBR( (IBRCH(2)+3),SS(2)))

! 1080:[breaker1] Single Phase Breaker 'DCCI2'
      IVD1_2 = NSTORI
      NSTORI = NSTORI + 1
      CALL E1PBRKR1_EXE(SS(2), (IBRCH(2)+5),0.0001,1000000.0,1,NINT(1.0-&
     &REAL(DCCI2)))
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(2)+5),SS(2)))
      IF (FIRSTSTEP .OR. (STORI(IVD1_2) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,812126962,IVD1_1,"BOpen")
      ENDIF
      STORI(IVD1_2) = 2*E_BtoI(OPENBR( (IBRCH(2)+5),SS(2)))

! 1090:[breaker3] 3 Phase Breaker 'CAPPRECHRGI'
      IVD1_4 = NSTORI
      NSTORI = NSTORI + 3
! Three Phase Breaker
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+25),0.005,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(CAPPRECHRGI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+26),0.005,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(CAPPRECHRGI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+27),0.005,100000000.0,RTCF(NR&
     &TCF),0,NINT(1.0-REAL(CAPPRECHRGI)))
!
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(1)+25),SS(1)))
      IVD1_2 = 2*E_BtoI(OPENBR( (IBRCH(1)+26),SS(1)))
      IVD1_3 = 2*E_BtoI(OPENBR( (IBRCH(1)+27),SS(1)))
      NRTCF = NRTCF + 1
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+0) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,1356420007,IVD1_1,"BOpen1")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+1) .NE. IVD1_2)) THEN
         CALL PSCAD_AGI2(ICALL_NO,1356420007,IVD1_2,"BOpen2")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+2) .NE. IVD1_3)) THEN
         CALL PSCAD_AGI2(ICALL_NO,1356420007,IVD1_3,"BOpen3")
      ENDIF
      STORI(IVD1_4+0) = 2*E_BtoI(OPENBR( (IBRCH(1)+25),SS(1)))
      STORI(IVD1_4+1) = 2*E_BtoI(OPENBR( (IBRCH(1)+26),SS(1)))
      STORI(IVD1_4+2) = 2*E_BtoI(OPENBR( (IBRCH(1)+27),SS(1)))

! 1100:[breaker3] 3 Phase Breaker 'CAPCONI'
      IVD1_4 = NSTORI
      NSTORI = NSTORI + 3
! Three Phase Breaker
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+19),0.01,100000000.0,RTCF(NRT&
     &CF),0,NINT(1.0-REAL(CAPCONI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+20),0.01,100000000.0,RTCF(NRT&
     &CF),0,NINT(1.0-REAL(CAPCONI)))
      CALL EMTDC_BREAKER1(SS(1), (IBRCH(1)+21),0.01,100000000.0,RTCF(NRT&
     &CF),0,NINT(1.0-REAL(CAPCONI)))
!
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(1)+19),SS(1)))
      IVD1_2 = 2*E_BtoI(OPENBR( (IBRCH(1)+20),SS(1)))
      IVD1_3 = 2*E_BtoI(OPENBR( (IBRCH(1)+21),SS(1)))
      NRTCF = NRTCF + 1
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+0) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,2045792080,IVD1_1,"BOpen1")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+1) .NE. IVD1_2)) THEN
         CALL PSCAD_AGI2(ICALL_NO,2045792080,IVD1_2,"BOpen2")
      ENDIF
      IF (FIRSTSTEP .OR. (STORI(IVD1_4+2) .NE. IVD1_3)) THEN
         CALL PSCAD_AGI2(ICALL_NO,2045792080,IVD1_3,"BOpen3")
      ENDIF
      STORI(IVD1_4+0) = 2*E_BtoI(OPENBR( (IBRCH(1)+19),SS(1)))
      STORI(IVD1_4+1) = 2*E_BtoI(OPENBR( (IBRCH(1)+20),SS(1)))
      STORI(IVD1_4+2) = 2*E_BtoI(OPENBR( (IBRCH(1)+21),SS(1)))

! 1110:[varrlc] Variable R, L or C  
      CALL COMPONENT_ID(ICALL_NO,462633811)
      CALL E_VARRLC1_EXE(1 ,SS(1) ,  (IBRCH(1)+13), 0, L_Filter, 0.0)
      CALL E_VARRLC1_EXE(1 ,SS(1) ,  (IBRCH(1)+14), 0, L_Filter, 0.0)
      CALL E_VARRLC1_EXE(1 ,SS(1) ,  (IBRCH(1)+15), 0, L_Filter, 0.0)

! 1120:[varrlc] Variable R, L or C  
      CALL COMPONENT_ID(ICALL_NO,1366680628)
      CALL E_VARRLC1_EXE(0 ,SS(1) ,  (IBRCH(1)+16), 0, R_Filter, 0.0)
      CALL E_VARRLC1_EXE(0 ,SS(1) ,  (IBRCH(1)+17), 0, R_Filter, 0.0)
      CALL E_VARRLC1_EXE(0 ,SS(1) ,  (IBRCH(1)+18), 0, R_Filter, 0.0)

! 1130:[AvgBridge]  
      CALL AvgBridgeDyn(EnaPWM, DutyCycle)


! 1140:[varrlc] Variable R, L or C  
      CALL COMPONENT_ID(ICALL_NO,1692730291)
      CALL E_VARRLC1_EXE(2 ,SS(2) ,  (IBRCH(2)+7), 0, C_Dcl, 0.0)

! 1160:[breaker1] Single Phase Breaker 'DCCI1'
      IVD1_2 = NSTORI
      NSTORI = NSTORI + 1
      CALL E1PBRKR1_EXE(SS(2), (IBRCH(2)+1),0.0001,1000000.0,1,NINT(1.0-&
     &REAL(DCCI1)))
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(2)+1),SS(2)))
      IF (FIRSTSTEP .OR. (STORI(IVD1_2) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,124265150,IVD1_1,"BOpen")
      ENDIF
      STORI(IVD1_2) = 2*E_BtoI(OPENBR( (IBRCH(2)+1),SS(2)))

! 1170:[breaker1] Single Phase Breaker 'FST_BRK'
      IVD1_2 = NSTORI
      NSTORI = NSTORI + 1
      CALL E1PBRKR1_EXE(SS(2), (IBRCH(2)+4),1.0,1000000.0,1,NINT(1.0-REA&
     &L(FST_BRK)))
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(2)+4),SS(2)))
      IF (FIRSTSTEP .OR. (STORI(IVD1_2) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI2(ICALL_NO,1399995169,IVD1_1,"BOpen")
      ENDIF
      STORI(IVD1_2) = 2*E_BtoI(OPENBR( (IBRCH(2)+4),SS(2)))

!---------------------------------------
! Feedbacks and transfers to storage 
!---------------------------------------

      STOI(ISTOI + 1) = FileNum
      STOI(ISTOI + 2) = InvPwrVolTyp_
      STOI(ISTOI + 3) = GriCod_
      STOI(ISTOI + 4) = Log2File
      STOI(ISTOI + 5) = FastStart
      STOF(ISTOF + 153) = EnaPWM
      STOI(ISTOI + 6) = IT_1
      STOF(ISTOF + 157) = ExtVRMS
      STOF(ISTOF + 162) = VAREF
      STOF(ISTOF + 163) = VPWM
      STOF(ISTOF + 164) = VBREF
      STOF(ISTOF + 167) = VCREF
      STOF(ISTOF + 176) = ExtVtgAB
      STOF(ISTOF + 177) = ExtVtgBC
      STOF(ISTOF + 178) = ExtVtgCA
      STOF(ISTOF + 179) = CnvVtgAB
      STOF(ISTOF + 180) = CnvVtgBC
      STOF(ISTOF + 181) = CnvVtgCA
      STOI(ISTOI + 7) = ACC
      STOI(ISTOI + 8) = ACCI
      STOF(ISTOF + 192) = PVCurFil
      STOF(ISTOF + 193) = RT_13
      STOF(ISTOF + 200) = PVVtgFil
      STOF(ISTOF + 201) = RT_15
      STOF(ISTOF + 202) = DCLinkVtgFil
      STOF(ISTOF + 203) = RT_16
      STOF(ISTOF + 206) = DeadTime
      STOI(ISTOI + 9) = Up
      STOI(ISTOI + 10) = Execute
      STOI(ISTOI + 11) = CapCon
      STOI(ISTOI + 12) = CAPCONI
      STOF(ISTOF + 223) = VDCRef
      STOI(ISTOI + 13) = FileNo
      STOI(ISTOI + 14) = InvPwrVolTyp
      STOI(ISTOI + 15) = Log2File_
      STOI(ISTOI + 16) = FastStart_
      STOI(ISTOI + 17) = DCCI1
      STOI(ISTOI + 18) = DCCI
      STOI(ISTOI + 19) = DCCI2
      STOI(ISTOI + 20) = PreChrg
      STOI(ISTOI + 21) = PRECHRGI
      STOF(ISTOF + 274) = RT_19
      STOF(ISTOF + 275) = RT_20
      STOF(ISTOF + 276) = RT_21
      STOF(ISTOF + 277) = RT_22
      STOI(ISTOI + 22) = CAPPRECHRG
      STOI(ISTOI + 23) = CAPPRECHRGI
      STOF(ISTOF + 278) = RT_23
      STOI(ISTOI + 24) = DCC
      STOF(ISTOF + 309) = RT_24
      STOF(ISTOF + 316) = RT_25
      STOF(ISTOF + 317) = RT_26
      STOF(ISTOF + 318) = RT_27
      STOF(ISTOF + 331) = CnvPAC
      STOF(ISTOF + 332) = CnvQAC
      STOF(ISTOF + 333) = PVVtg
      STOF(ISTOF + 334) = Ipv
      STOF(ISTOF + 335) = DCLinkVtg
      STOI(ISTOI + 25) = GriCod
      STOF(ISTOF + 336) = RT_28
      STOF(ISTOF + 337) = RT_29
      STOI(ISTOI + 26) = FST_BRK
      STOF(ISTOF + 338) = FPWM
      STOF(ISTOF + 339) = C_Filter
      STOF(ISTOF + 340) = L_Filter
      STOF(ISTOF + 341) = R_Filter
      STOF(ISTOF + 346) = C_Dcl
      STOF(ISTOF + 397) = PVCur
      STOF(ISTOF + 398) = Istk

! Array (1:2) quantities...
      DO IT_0 = 1,2
         STOF(ISTOF + 157 + IT_0) = RT_1(IT_0)
         STOF(ISTOF + 159 + IT_0) = RT_2(IT_0)
         STOF(ISTOF + 164 + IT_0) = RT_3(IT_0)
         STOF(ISTOF + 167 + IT_0) = RT_4(IT_0)
         STOF(ISTOF + 169 + IT_0) = RT_5(IT_0)
         STOF(ISTOF + 171 + IT_0) = RT_6(IT_0)
         STOF(ISTOF + 173 + IT_0) = RT_7(IT_0)
         STOF(ISTOF + 181 + IT_0) = RT_8(IT_0)
         STOF(ISTOF + 183 + IT_0) = RT_9(IT_0)
         STOF(ISTOF + 185 + IT_0) = RT_10(IT_0)
         STOF(ISTOF + 187 + IT_0) = RT_11(IT_0)
         STOF(ISTOF + 189 + IT_0) = RT_12(IT_0)
         STOF(ISTOF + 203 + IT_0) = g1(IT_0)
         STOF(ISTOF + 206 + IT_0) = g4(IT_0)
         STOF(ISTOF + 208 + IT_0) = g3(IT_0)
         STOF(ISTOF + 210 + IT_0) = g6(IT_0)
         STOF(ISTOF + 212 + IT_0) = g5(IT_0)
         STOF(ISTOF + 214 + IT_0) = g2(IT_0)
      END DO

! Array (1:3) quantities...
      DO IT_0 = 1,3
         STOF(ISTOF + 153 + IT_0) = DutyCycle(IT_0)
         STOF(ISTOF + 193 + IT_0) = RT_14(IT_0)
         STOF(ISTOF + 196 + IT_0) = StackCur_(IT_0)
         STOF(ISTOF + 216 + IT_0) = StackCurFil(IT_0)
         STOF(ISTOF + 219 + IT_0) = RT_17(IT_0)
         STOF(ISTOF + 309 + IT_0) = CnvVtgFil(IT_0)
         STOF(ISTOF + 312 + IT_0) = ExtVtgFil(IT_0)
         STOF(ISTOF + 318 + IT_0) = ExtVtg(IT_0)
         STOF(ISTOF + 321 + IT_0) = CnvVtg(IT_0)
         STOF(ISTOF + 324 + IT_0) = StackCur(IT_0)
         STOF(ISTOF + 327 + IT_0) = CnvCurABC(IT_0)
      END DO

! Array (1:4) quantities...
      DO IT_0 = 1,4
         STOF(ISTOF + 341 + IT_0) = HwParam(IT_0)
      END DO

! Array (1:5) quantities...
      DO IT_0 = 1,5
         STOF(ISTOF + 20 + IT_0) = DPS_Spt(IT_0)
      END DO

! Array (1:10) quantities...
      DO IT_0 = 1,10
         STOF(ISTOF + 0 + IT_0) = Spt(IT_0)
         STOF(ISTOF + 10 + IT_0) = Fb(IT_0)
         STOF(ISTOF + 25 + IT_0) = DPS_Fb(IT_0)
         STOF(ISTOF + 298 + IT_0) = ZeroArray(IT_0)
      END DO

! Array (1:17) quantities...
      DO IT_0 = 1,17
         STOF(ISTOF + 135 + IT_0) = MEAS_PCU(IT_0)
      END DO

! Array (1:20) quantities...
      DO IT_0 = 1,20
         STOF(ISTOF + 278 + IT_0) = Meas(IT_0)
      END DO

! Array (1:50) quantities...
      DO IT_0 = 1,50
         STOF(ISTOF + 223 + IT_0) = RT_18(IT_0)
         STOF(ISTOF + 346 + IT_0) = xout(IT_0)
      END DO

! Array (1:100) quantities...
      DO IT_0 = 1,100
         STOF(ISTOF + 35 + IT_0) = DEBUG_PCU(IT_0)
      END DO


!---------------------------------------
! Transfer to Exports
!---------------------------------------
      !Fb       is output
      !DPS_Spt  is output
      !DEBUG_PCU is output
      !MEAS_PCU is output

!---------------------------------------
! Close Model Data read 
!---------------------------------------

      IF ( TIMEZERO ) CALL EMTDC_CLOSEFILE
      RETURN
      END

!=======================================================================

      SUBROUTINE SCxxxxOut()

!---------------------------------------
! Standard includes 
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 'emtstor.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's2.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'fnames.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'matlab.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations 
!---------------------------------------

      REAL    EMTDC_VVDC    ! 
!     SUBR    TFNN35        ! Nth-order Transfer Function
!     SUBR    FILN15        ! Nth-order Butterworth/Chebyshev Filter
      REAL    VBRANCH       ! 
!     SUBR    AvgBridgeOut  ! 
      REAL    VM3PH2        ! '3 Phase RMS Voltage Measurement'

!---------------------------------------
! Variable Declarations 
!---------------------------------------


! Electrical Node Indices
      INTEGER  AC(3), DC_Neg, DPS_Pos, DPS_Neg
      INTEGER  NT_4, NT_18, NT_19, NT_20, NT_21
      INTEGER  NT_22, NT_23

! Control Signals
      INTEGER  IT_1
      REAL     ExtVRMS, ExtVtgAB, ExtVtgBC
      REAL     ExtVtgCA, CnvVtgAB, CnvVtgBC
      REAL     CnvVtgCA, PVCurFil, RT_13
      REAL     RT_14(3), StackCur_(3), PVVtgFil
      REAL     RT_15, DCLinkVtgFil, RT_16
      REAL     DeadTime, StackCurFil(3), RT_17(3)
      REAL     VDCRef, CnvVtgFil(3), ExtVtgFil(3)
      REAL     RT_25, RT_26, RT_27, ExtVtg(3)
      REAL     CnvVtg(3), StackCur(3)
      REAL     CnvCurABC(3), CnvPAC, CnvQAC
      REAL     PVVtg, Ipv, DCLinkVtg, PVCur, Istk

! Internal Variables
      INTEGER  IVD1_1
      REAL     RVD11_1(11), RVD11_2(11)
      REAL     RVD10_1(10), RVD1_1, RVD1_2

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER ISTOL, ISTOI, ISTOF, ISTOC, IT_0    ! Storage Indices
      INTEGER ISUBS, SS(2), IBRCH(2), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices 
!---------------------------------------

! Dsdyn <-> Dsout transfer index storage

      NTXFR = NTXFR + 1

      ISTOL = TXFR(NTXFR,1)
      ISTOI = TXFR(NTXFR,2)
      ISTOF = TXFR(NTXFR,3)
      ISTOC = TXFR(NTXFR,4)

! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      INODE     = NNODE + 2
      NNODE     = NNODE + 35
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 2

      DO IT_0 = 1,2
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 32


      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 8

!---------------------------------------
! Transfers from storage arrays 
!---------------------------------------

      IT_1     = STOI(ISTOI + 6)
      ExtVRMS  = STOF(ISTOF + 157)
      ExtVtgAB = STOF(ISTOF + 176)
      ExtVtgBC = STOF(ISTOF + 177)
      ExtVtgCA = STOF(ISTOF + 178)
      CnvVtgAB = STOF(ISTOF + 179)
      CnvVtgBC = STOF(ISTOF + 180)
      CnvVtgCA = STOF(ISTOF + 181)
      PVCurFil = STOF(ISTOF + 192)
      RT_13    = STOF(ISTOF + 193)
      PVVtgFil = STOF(ISTOF + 200)
      RT_15    = STOF(ISTOF + 201)
      DCLinkVtgFil = STOF(ISTOF + 202)
      RT_16    = STOF(ISTOF + 203)
      DeadTime = STOF(ISTOF + 206)
      VDCRef   = STOF(ISTOF + 223)
      RT_25    = STOF(ISTOF + 316)
      RT_26    = STOF(ISTOF + 317)
      RT_27    = STOF(ISTOF + 318)
      CnvPAC   = STOF(ISTOF + 331)
      CnvQAC   = STOF(ISTOF + 332)
      PVVtg    = STOF(ISTOF + 333)
      Ipv      = STOF(ISTOF + 334)
      DCLinkVtg = STOF(ISTOF + 335)
      PVCur    = STOF(ISTOF + 397)
      Istk     = STOF(ISTOF + 398)

! Array (1:3) quantities...
      DO IT_0 = 1,3
         RT_14(IT_0) = STOF(ISTOF + 193 + IT_0)
         StackCur_(IT_0) = STOF(ISTOF + 196 + IT_0)
         StackCurFil(IT_0) = STOF(ISTOF + 216 + IT_0)
         RT_17(IT_0) = STOF(ISTOF + 219 + IT_0)
         CnvVtgFil(IT_0) = STOF(ISTOF + 309 + IT_0)
         ExtVtgFil(IT_0) = STOF(ISTOF + 312 + IT_0)
         ExtVtg(IT_0) = STOF(ISTOF + 318 + IT_0)
         CnvVtg(IT_0) = STOF(ISTOF + 321 + IT_0)
         StackCur(IT_0) = STOF(ISTOF + 324 + IT_0)
         CnvCurABC(IT_0) = STOF(ISTOF + 327 + IT_0)
      END DO


!---------------------------------------
! Electrical Node Lookup 
!---------------------------------------

      DC_Neg = NODE(INODE + 5)
      DPS_Pos = NODE(INODE + 6)
      DPS_Neg = NODE(INODE + 7)
      NT_4  = NODE(INODE + 15)
      NT_18 = NODE(INODE + 16)
      NT_19 = NODE(INODE + 17)
      NT_20 = NODE(INODE + 18)
      NT_21 = NODE(INODE + 1)
      NT_22 = NODE(INODE + 2)
      NT_23 = NODE(INODE + 3)

! Array (1:3) quantities...
      DO IT_0 = 1,3
         AC(IT_0) = NODE(INODE + 0 + IT_0)
      END DO

!---------------------------------------
! Configuration of Models 
!---------------------------------------

      IF ( TIMEZERO ) THEN
         FILENAME = 'SCxxxx.dta'
         CALL EMTDC_OPENFILE
         SECTION = 'DATADSO:'
         CALL EMTDC_GOTOSECTION
      ENDIF
!---------------------------------------
! Generated code from module definition 
!---------------------------------------


! 40:[const] Real Constant 

      VDCRef = 750.0

! 50:[ammeter] Current Meter 'Ipv'
      Ipv = ( CBR((IBRCH(2)+2), SS(2)))

! 60:[ammeter] Current Meter 'Istk'
      Istk = ( CBR((IBRCH(2)+6), SS(2)))

! 70:[voltmeter] Voltmeter (Line - Line) 'PVVtg'
      PVVtg = EMTDC_VVDC(SS(2), NT_4, DC_Neg)

! 80:[voltmeter] Voltmeter (Line - Line) 'DCLinkVtg'
      DCLinkVtg = EMTDC_VVDC(SS(2), DPS_Pos, DPS_Neg)

! 90:[ammeter] Current Meter 'StackCur'
      StackCur(1) = ( CBR((IBRCH(1)+1), SS(1)))
      StackCur(2) = ( CBR((IBRCH(1)+2), SS(1)))
      StackCur(3) = ( CBR((IBRCH(1)+3), SS(1)))

! 100:[ammeter] Current Meter 'CnvCurABC'
      CnvCurABC(1) = ( CBR((IBRCH(1)+7), SS(1)))
      CnvCurABC(2) = ( CBR((IBRCH(1)+8), SS(1)))
      CnvCurABC(3) = ( CBR((IBRCH(1)+9), SS(1)))

! 120:[voltmeter] Voltmeter (Line - Line) 'CnvVtgAB'
      CnvVtgAB = EMTDC_VVDC(SS(1), NT_18, NT_19)

! 130:[voltmeter] Voltmeter (Line - Line) 'CnvVtgBC'
      CnvVtgBC = EMTDC_VVDC(SS(1), NT_19, NT_20)

! 140:[voltmeter] Voltmeter (Line - Line) 'ExtVtgAB'
      ExtVtgAB = EMTDC_VVDC(SS(1), NT_21, NT_22)

! 150:[voltmeter] Voltmeter (Line - Line) 'ExtVtgBC'
      ExtVtgBC = EMTDC_VVDC(SS(1), NT_22, NT_23)

! 160:[voltmeter] Voltmeter (Line - Line) 'CnvVtgCA'
      CnvVtgCA = EMTDC_VVDC(SS(1), NT_20, NT_18)

! 170:[voltmeter] Voltmeter (Line - Line) 'ExtVtgCA'
      ExtVtgCA = EMTDC_VVDC(SS(1), NT_23, NT_21)

! 260:[datamerge] Merges data signals into an array 
      ExtVtg(1) = ExtVtgAB
      ExtVtg(2) = ExtVtgBC
      ExtVtg(3) = ExtVtgCA

! 270:[trans_fcn] Nth Order Transfer Function 
      CALL COMPONENT_ID(ICALL_NO,957450146)
!
!  TRANSFER FUNCTION
!
      RVD11_1(1) = 25190000.0
      RVD11_1(2) = 4524.0
      RVD11_1(3) = 0.4916
      RVD11_1(4) = 3.124e-05
      RVD11_1(5) = 1.0e-09
      RVD11_1(6) = 0.0
      RVD11_1(7) = 0.0
      RVD11_1(8) = 0.0
      RVD11_1(9) = 0.0
      RVD11_1(10) = 0.0
      RVD11_1(11) = 0.0
!
      RVD11_2(1) = 25190000.0
      RVD11_2(2) = 269.7
      RVD11_2(3) = 0.08435
      RVD11_2(4) = 7.428e-07
      RVD11_2(5) = 3.042e-11
      RVD11_2(6) = 0.0
      RVD11_2(7) = 0.0
      RVD11_2(8) = 0.0
      RVD11_2(9) = 0.0
      RVD11_2(10) = 0.0
      RVD11_2(11) = 0.0
!
      RVD10_1(1) = 0.0
      RVD10_1(2) = 0.0
      RVD10_1(3) = 0.0
      RVD10_1(4) = 0.0
      RVD10_1(5) = 0.0
      RVD10_1(6) = 0.0
      RVD10_1(7) = 0.0
      RVD10_1(8) = 0.0
      RVD10_1(9) = 0.0
      RVD10_1(10) = 0.0
!
      DO IVD1_1 = 1,3
        CALL TFNN35(4,RVD11_2,RVD11_1,RVD10_1,0, 1.0,ExtVtg(IVD1_1),RT_1&
     &7(IVD1_1))
      ENDDO

! 280:[gain] Gain Block 
!  Gain
      ExtVtgFil = 1000.0 * RT_17

! 320:[const] Real Constant 'TDead'

      DeadTime = 0.0

! 330:[datamerge] Merges data signals into an array 
      CnvVtg(1) = CnvVtgAB
      CnvVtg(2) = CnvVtgBC
      CnvVtg(3) = CnvVtgCA

! 340:[trans_fcn] Nth Order Transfer Function 
      CALL COMPONENT_ID(ICALL_NO,1980761773)
!
!  TRANSFER FUNCTION
!
      RVD11_1(1) = 25190000.0
      RVD11_1(2) = 4524.0
      RVD11_1(3) = 0.4916
      RVD11_1(4) = 3.124e-05
      RVD11_1(5) = 1.0e-09
      RVD11_1(6) = 0.0
      RVD11_1(7) = 0.0
      RVD11_1(8) = 0.0
      RVD11_1(9) = 0.0
      RVD11_1(10) = 0.0
      RVD11_1(11) = 0.0
!
      RVD11_2(1) = 25190000.0
      RVD11_2(2) = 269.7
      RVD11_2(3) = 0.08435
      RVD11_2(4) = 7.428e-07
      RVD11_2(5) = 3.042e-11
      RVD11_2(6) = 0.0
      RVD11_2(7) = 0.0
      RVD11_2(8) = 0.0
      RVD11_2(9) = 0.0
      RVD11_2(10) = 0.0
      RVD11_2(11) = 0.0
!
      RVD10_1(1) = 0.0
      RVD10_1(2) = 0.0
      RVD10_1(3) = 0.0
      RVD10_1(4) = 0.0
      RVD10_1(5) = 0.0
      RVD10_1(6) = 0.0
      RVD10_1(7) = 0.0
      RVD10_1(8) = 0.0
      RVD10_1(9) = 0.0
      RVD10_1(10) = 0.0
!
      DO IVD1_1 = 1,3
        CALL TFNN35(4,RVD11_2,RVD11_1,RVD10_1,0, 1.0,CnvVtg(IVD1_1),RT_1&
     &4(IVD1_1))
      ENDDO

! 350:[gain] Gain Block 
!  Gain
      CnvVtgFil = 1000.0 * RT_14

! 360:[gain] Gain Block 
!  Gain
      StackCur_ = 1000.0 * StackCur

! 370:[trans_fcn] Nth Order Transfer Function 
      CALL COMPONENT_ID(ICALL_NO,298741217)
!
!  TRANSFER FUNCTION
!
      RVD11_1(1) = 25190000.0
      RVD11_1(2) = 4524.0
      RVD11_1(3) = 0.4916
      RVD11_1(4) = 3.124e-05
      RVD11_1(5) = 1.0e-09
      RVD11_1(6) = 0.0
      RVD11_1(7) = 0.0
      RVD11_1(8) = 0.0
      RVD11_1(9) = 0.0
      RVD11_1(10) = 0.0
      RVD11_1(11) = 0.0
!
      RVD11_2(1) = 25190000.0
      RVD11_2(2) = 269.7
      RVD11_2(3) = 0.08435
      RVD11_2(4) = 7.428e-07
      RVD11_2(5) = 3.042e-11
      RVD11_2(6) = 0.0
      RVD11_2(7) = 0.0
      RVD11_2(8) = 0.0
      RVD11_2(9) = 0.0
      RVD11_2(10) = 0.0
      RVD11_2(11) = 0.0
!
      RVD10_1(1) = 0.0
      RVD10_1(2) = 0.0
      RVD10_1(3) = 0.0
      RVD10_1(4) = 0.0
      RVD10_1(5) = 0.0
      RVD10_1(6) = 0.0
      RVD10_1(7) = 0.0
      RVD10_1(8) = 0.0
      RVD10_1(9) = 0.0
      RVD10_1(10) = 0.0
!
      DO IVD1_1 = 1,3
        CALL TFNN35(4,RVD11_2,RVD11_1,RVD10_1,0, 1.0,StackCur_(IVD1_1),S&
     &tackCurFil(IVD1_1))
      ENDDO

! 380:[const] Real Constant 

      RT_25 = 0.0

! 390:[trans_filt] Nth Order Butterworth/Chebyshev Filter 
!
!  BUTTERWORTH FILTER
!
      CALL COMPONENT_ID(ICALL_NO,715774171)
      CALL FILN15(1,100.0,0.0, 0.0 ,1,1,0,PVVtg,RT_15)
!

! 400:[gain] Gain Block 
!  Gain
      PVVtgFil = 1000.0 * RT_15

! 410:[const] Real Constant 

      RT_26 = 0.0

! 420:[trans_filt] Nth Order Butterworth/Chebyshev Filter 
!
!  BUTTERWORTH FILTER
!
      CALL COMPONENT_ID(ICALL_NO,946587674)
      CALL FILN15(1,100.0,0.0, 0.0 ,1,1,0,Ipv,RT_13)
!

! 430:[gain] Gain Block 
!  Gain
      PVCurFil = 1000.0 * RT_13

! 440:[trans_filt] Nth Order Butterworth/Chebyshev Filter 
!
!  BUTTERWORTH FILTER
!
      CALL COMPONENT_ID(ICALL_NO,1377145039)
      CALL FILN15(1,1000.0,0.0, 0.0 ,1,1,0,DCLinkVtg,RT_16)
!

! 450:[gain] Gain Block 
!  Gain
      DCLinkVtgFil = 1000.0 * RT_16

! 460:[const] Real Constant 'Zero'

      RT_27 = 0.0

! 800:[breaker3] 3 Phase Breaker 'ACCI'
! Three Phase Breaker Currents
      CALL BRK_POWER(SS(1), (IBRCH(1)+4), (IBRCH(1)+5), (IBRCH(1)+6),0,0&
     &,0,IVD1_1,0.02,RVD1_1,RVD1_2)
      IF (UPDATE_AG) THEN
        CALL PSCAD_AGR2(ICALL_NO,945457058,RVD1_1,"P")
        CALL PSCAD_AGR2(ICALL_NO,945457058,RVD1_2,"Q")
      ENDIF
      CnvPAC = RVD1_1
      CnvQAC = RVD1_2

! 1060:[breaker3] 3 Phase Breaker 'PRECHRGI'
! Three Phase Breaker Currents
      CALL BRK_POWER(SS(1), (IBRCH(1)+22), (IBRCH(1)+23), (IBRCH(1)+24),&
     &0,0,0,IVD1_1,0.02,RVD1_1,RVD1_2)

! 1070:[breaker1] Single Phase Breaker 'FST_BRK'
! Single phase breaker current
!

! 1080:[breaker1] Single Phase Breaker 'DCCI2'
! Single phase breaker current
!

! 1090:[breaker3] 3 Phase Breaker 'CAPPRECHRGI'
! Three Phase Breaker Currents
      CALL BRK_POWER(SS(1), (IBRCH(1)+25), (IBRCH(1)+26), (IBRCH(1)+27),&
     &0,0,0,IVD1_1,0.02,RVD1_1,RVD1_2)

! 1100:[breaker3] 3 Phase Breaker 'CAPCONI'
! Three Phase Breaker Currents
      CALL BRK_POWER(SS(1), (IBRCH(1)+19), (IBRCH(1)+20), (IBRCH(1)+21),&
     &0,0,0,IVD1_1,0.02,RVD1_1,RVD1_2)

! 1130:[AvgBridge]  
      CALL AvgBridgeOut()


! 1150:[rms3ph] Three Phase RMS Meter 
      RVD1_1 = RTCF(NRTCF) ! Inverse of rated voltage
      NRTCF = NRTCF + 1
      ExtVRMS = RVD1_1 * VM3PH2(SS(1), AC(1), AC(2), AC(3), 0.0025)
!

! 1160:[breaker1] Single Phase Breaker 'DCCI1'
! Single phase breaker current
      PVCur = ( CBR((IBRCH(2)+1), SS(2)))
!

! 1170:[breaker1] Single Phase Breaker 'FST_BRK'
! Single phase breaker current
!

!---------------------------------------
! Feedbacks and transfers to storage 
!---------------------------------------

      STOI(ISTOI + 6) = IT_1
      STOF(ISTOF + 157) = ExtVRMS
      STOF(ISTOF + 176) = ExtVtgAB
      STOF(ISTOF + 177) = ExtVtgBC
      STOF(ISTOF + 178) = ExtVtgCA
      STOF(ISTOF + 179) = CnvVtgAB
      STOF(ISTOF + 180) = CnvVtgBC
      STOF(ISTOF + 181) = CnvVtgCA
      STOF(ISTOF + 192) = PVCurFil
      STOF(ISTOF + 193) = RT_13
      STOF(ISTOF + 200) = PVVtgFil
      STOF(ISTOF + 201) = RT_15
      STOF(ISTOF + 202) = DCLinkVtgFil
      STOF(ISTOF + 203) = RT_16
      STOF(ISTOF + 206) = DeadTime
      STOF(ISTOF + 223) = VDCRef
      STOF(ISTOF + 316) = RT_25
      STOF(ISTOF + 317) = RT_26
      STOF(ISTOF + 318) = RT_27
      STOF(ISTOF + 331) = CnvPAC
      STOF(ISTOF + 332) = CnvQAC
      STOF(ISTOF + 333) = PVVtg
      STOF(ISTOF + 334) = Ipv
      STOF(ISTOF + 335) = DCLinkVtg
      STOF(ISTOF + 397) = PVCur
      STOF(ISTOF + 398) = Istk

! Array (1:3) quantities...
      DO IT_0 = 1,3
         STOF(ISTOF + 193 + IT_0) = RT_14(IT_0)
         STOF(ISTOF + 196 + IT_0) = StackCur_(IT_0)
         STOF(ISTOF + 216 + IT_0) = StackCurFil(IT_0)
         STOF(ISTOF + 219 + IT_0) = RT_17(IT_0)
         STOF(ISTOF + 309 + IT_0) = CnvVtgFil(IT_0)
         STOF(ISTOF + 312 + IT_0) = ExtVtgFil(IT_0)
         STOF(ISTOF + 318 + IT_0) = ExtVtg(IT_0)
         STOF(ISTOF + 321 + IT_0) = CnvVtg(IT_0)
         STOF(ISTOF + 324 + IT_0) = StackCur(IT_0)
         STOF(ISTOF + 327 + IT_0) = CnvCurABC(IT_0)
      END DO


!---------------------------------------
! Close Model Data read 
!---------------------------------------

      IF ( TIMEZERO ) CALL EMTDC_CLOSEFILE
      RETURN
      END

!=======================================================================

      SUBROUTINE SCxxxxDyn_Begin(FileNum, InvPwrVolTyp_, GriCod_,       &
     &   Log2File, FastStart)

!---------------------------------------
! Standard includes 
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations 
!---------------------------------------

!     SUBR    AvgBridgeDyn_Begin  ! 

!---------------------------------------
! Variable Declarations 
!---------------------------------------


! Subroutine Arguments
      INTEGER, INTENT(IN)  :: FileNum
      INTEGER, INTENT(IN)  :: InvPwrVolTyp_
      INTEGER, INTENT(IN)  :: GriCod_, Log2File
      INTEGER, INTENT(IN)  :: FastStart

! Electrical Node Indices

! Control Signals
      REAL     DeadTime, VDCRef, RT_25, RT_26
      REAL     RT_27

! Internal Variables

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER IT_0                                ! Storage Indices
      INTEGER ISUBS, SS(2), IBRCH(2), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices 
!---------------------------------------


! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      INODE     = NNODE + 2
      NNODE     = NNODE + 35
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 2

      DO IT_0 = 1,2
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 32


      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 8

!---------------------------------------
! Electrical Node Lookup 
!---------------------------------------


!---------------------------------------
! Generated code from module definition 
!---------------------------------------


! 30:[time-sig] Output of Simulation Time 

! 40:[const] Real Constant 
      VDCRef = 750.0

! 190:[unity] Type/Shape conversion block 

! 210:[unity] Type/Shape conversion block 

! 230:[unity] Type/Shape conversion block 

! 250:[unity] Type/Shape conversion block 

! 300:[unity] Type/Shape conversion block 

! 310:[time-sig] Output of Simulation Time 

! 320:[const] Real Constant 'TDead'
      DeadTime = 0.0

! 380:[const] Real Constant 
      RT_25 = 0.0

! 410:[const] Real Constant 
      RT_26 = 0.0

! 460:[const] Real Constant 'Zero'
      RT_27 = 0.0

! 470:[gain] Gain Block 

! 480:[compar] Two Input Comparator 

! 490:[datamerge] Merges data signals into an array 

! 500:[datamerge] Merges data signals into an array 

! 510:[datamerge] Merges data signals into an array 

! 530:[SMA_SCK] Sunny Central - SMA Controller model 

! 540:[datatap] Scalar/Array Tap 

! 550:[datatap] Scalar/Array Tap 

! 560:[datatap] Scalar/Array Tap 

! 570:[datatap] Scalar/Array Tap 

! 580:[datatap] Scalar/Array Tap 

! 590:[compar] Two Input Comparator 

! 600:[compar] Two Input Comparator 

! 610:[compar] Two Input Comparator 

! 620:[datatap] Scalar/Array Tap 

! 630:[inv] Interpolated Logic Inverter 

! 640:[inv] Interpolated Logic Inverter 

! 650:[inv] Interpolated Logic Inverter 

! 660:[datatap] Scalar/Array Tap 

! 670:[datatap] Scalar/Array Tap 

! 680:[datatap] Scalar/Array Tap 

! 690:[datatap] Scalar/Array Tap 

! 700:[unity] Type/Shape conversion block 

! 710:[datatap] Scalar/Array Tap 

! 720:[gain] Gain Block 

! 730:[gain] Gain Block 

! 740:[gain] Gain Block 

! 750:[unity] Type/Shape conversion block 

! 760:[unity] Type/Shape conversion block 

! 770:[unity] Type/Shape conversion block 

! 780:[unity] Type/Shape conversion block 

! 790:[inv] Interpolated Logic Inverter 

! 800:[breaker3] 3 Phase Breaker 'ACCI'
      CALL COMPONENT_ID(ICALL_NO,945457058)
      RTCF(NRTCF) = ABS(0.0)
      NRTCF = NRTCF + 1

! 810:[datatap] Scalar/Array Tap 

! 820:[datatap] Scalar/Array Tap 

! 830:[datatap] Scalar/Array Tap 

! 840:[datatap] Scalar/Array Tap 

! 850:[datamerge] Merges data signals into an array 

! 860:[datatap] Scalar/Array Tap 

! 870:[delay] Binary ON Delay with Interpolation 

! 880:[gain] Gain Block 

! 890:[delay] Binary ON Delay with Interpolation 

! 910:[delay] Binary ON Delay with Interpolation 

! 920:[gain] Gain Block 

! 930:[delay] Binary ON Delay with Interpolation 

! 940:[delay] Binary ON Delay with Interpolation 

! 950:[inv] Interpolated Logic Inverter 

! 960:[gain] Gain Block 

! 970:[delay] Binary ON Delay with Interpolation 

! 980:[inv] Interpolated Logic Inverter 

! 990:[inv] Interpolated Logic Inverter 

! 1000:[inv] Interpolated Logic Inverter 

! 1010:[unity] Type/Shape conversion block 

! 1020:[unity] Type/Shape conversion block 

! 1030:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(2 ,SS(1) ,  (IBRCH(1)+12), 0)

! 1040:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(2 ,SS(1) ,  (IBRCH(1)+10), 0)

! 1050:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(2 ,SS(1) ,  (IBRCH(1)+11), 0)

! 1060:[breaker3] 3 Phase Breaker 'PRECHRGI'
      CALL COMPONENT_ID(ICALL_NO,1421691469)
      RTCF(NRTCF) = ABS(0.0)
      NRTCF = NRTCF + 1

! 1070:[breaker1] Single Phase Breaker 'FST_BRK'
      CALL COMPONENT_ID(ICALL_NO,640815522)
      CALL E1PBRKR1_CFG(1.0,1000000.0,0.0)

! 1080:[breaker1] Single Phase Breaker 'DCCI2'
      CALL COMPONENT_ID(ICALL_NO,812126962)
      CALL E1PBRKR1_CFG(0.0001,1000000.0,0.0)

! 1090:[breaker3] 3 Phase Breaker 'CAPPRECHRGI'
      CALL COMPONENT_ID(ICALL_NO,1356420007)
      RTCF(NRTCF) = ABS(0.0)
      NRTCF = NRTCF + 1

! 1100:[breaker3] 3 Phase Breaker 'CAPCONI'
      CALL COMPONENT_ID(ICALL_NO,2045792080)
      RTCF(NRTCF) = ABS(0.0)
      NRTCF = NRTCF + 1

! 1110:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(1 ,SS(1) ,  (IBRCH(1)+13), 0)
      CALL E_VARRLC1_CFG(1 ,SS(1) ,  (IBRCH(1)+14), 0)
      CALL E_VARRLC1_CFG(1 ,SS(1) ,  (IBRCH(1)+15), 0)

! 1120:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(0 ,SS(1) ,  (IBRCH(1)+16), 0)
      CALL E_VARRLC1_CFG(0 ,SS(1) ,  (IBRCH(1)+17), 0)
      CALL E_VARRLC1_CFG(0 ,SS(1) ,  (IBRCH(1)+18), 0)

! 1130:[AvgBridge]  
      CALL AvgBridgeDyn_Begin()


! 1140:[varrlc] Variable R, L or C  
      CALL E_VARRLC1_CFG(2 ,SS(2) ,  (IBRCH(2)+7), 0)

! 1160:[breaker1] Single Phase Breaker 'DCCI1'
      CALL COMPONENT_ID(ICALL_NO,124265150)
      CALL E1PBRKR1_CFG(0.0001,1000000.0,0.0)

! 1170:[breaker1] Single Phase Breaker 'FST_BRK'
      CALL COMPONENT_ID(ICALL_NO,1399995169)
      CALL E1PBRKR1_CFG(1.0,1000000.0,0.0)

      RETURN
      END

!=======================================================================

      SUBROUTINE SCxxxxOut_Begin(FileNum, InvPwrVolTyp_, GriCod_,       &
     &   Log2File, FastStart)

!---------------------------------------
! Standard includes 
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations 
!---------------------------------------

!     SUBR    AvgBridgeOut_Begin  ! 

!---------------------------------------
! Variable Declarations 
!---------------------------------------


! Subroutine Arguments
      INTEGER, INTENT(IN)  :: FileNum
      INTEGER, INTENT(IN)  :: InvPwrVolTyp_
      INTEGER, INTENT(IN)  :: GriCod_, Log2File
      INTEGER, INTENT(IN)  :: FastStart

! Electrical Node Indices
      INTEGER  DC_Neg, DPS_Pos, DPS_Neg, NT_4
      INTEGER  NT_18, NT_19, NT_20, NT_21, NT_22
      INTEGER  NT_23

! Control Signals
      REAL     DeadTime, VDCRef, RT_25, RT_26
      REAL     RT_27

! Internal Variables

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER IT_0                                ! Storage Indices
      INTEGER ISUBS, SS(2), IBRCH(2), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices 
!---------------------------------------


! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      INODE     = NNODE + 2
      NNODE     = NNODE + 35
      NCSCS     = NCSCS + 0
      NCSCR     = NCSCR + 0

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 2

      DO IT_0 = 1,2
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 32


      IBRCH(2)     = NBRCH(SS(2))
      NBRCH(SS(2)) = NBRCH(SS(2)) + 8

!---------------------------------------
! Electrical Node Lookup 
!---------------------------------------

      DC_Neg = NODE(INODE + 5)
      DPS_Pos = NODE(INODE + 6)
      DPS_Neg = NODE(INODE + 7)
      NT_4  = NODE(INODE + 15)
      NT_18 = NODE(INODE + 16)
      NT_19 = NODE(INODE + 17)
      NT_20 = NODE(INODE + 18)
      NT_21 = NODE(INODE + 1)
      NT_22 = NODE(INODE + 2)
      NT_23 = NODE(INODE + 3)

!---------------------------------------
! Generated code from module definition 
!---------------------------------------


! 40:[const] Real Constant 
      VDCRef = 750.0

! 260:[datamerge] Merges data signals into an array 

! 270:[trans_fcn] Nth Order Transfer Function 

! 280:[gain] Gain Block 

! 320:[const] Real Constant 'TDead'
      DeadTime = 0.0

! 330:[datamerge] Merges data signals into an array 

! 340:[trans_fcn] Nth Order Transfer Function 

! 350:[gain] Gain Block 

! 360:[gain] Gain Block 

! 370:[trans_fcn] Nth Order Transfer Function 

! 380:[const] Real Constant 
      RT_25 = 0.0

! 390:[trans_filt] Nth Order Butterworth/Chebyshev Filter 

! 400:[gain] Gain Block 

! 410:[const] Real Constant 
      RT_26 = 0.0

! 420:[trans_filt] Nth Order Butterworth/Chebyshev Filter 

! 430:[gain] Gain Block 

! 440:[trans_filt] Nth Order Butterworth/Chebyshev Filter 

! 450:[gain] Gain Block 

! 460:[const] Real Constant 'Zero'
      RT_27 = 0.0

! 1130:[AvgBridge]  
      CALL AvgBridgeOut_Begin()


! 1150:[rms3ph] Three Phase RMS Meter 
      RTCF(NRTCF) = 1.0
      IF (1.0 .GT. 1.0E-20) RTCF(NRTCF) = 1.0/1.0
      NRTCF = NRTCF + 1

      RETURN
      END

